"""
This script is used to parse the complex XML layout generated by CRASS.
It doesn't use a DTD schema, instead it simply turns the whole data
into a Python dictionary object, making it similar to a hierarchic 
json structure.
"""


def import_crass_crispr(location):
    import xmltodict
    with open(location, 'r') as fd:
        doc = xmltodict.parse(fd.read())
    print("Done!")
    return doc


def extract_sources(group):
    """The read source IDs are local for a CRISPR group ID"""
    sources = {}
    for source in group[u'data'][u'sources'][u'source']:
        sources[source[u'@soid']] = source[u'@accession']
    return sources


def extract_spacers(group):
    """The spacer IDs are local to a CRISPR group ID"""
    spacers = {}
    for spacer in group[u'data'][u'spacers'][u'spacer']:
        spid = spacer[u'@spid']
        spseq = spacer[u'@seq']
        if len(spacer[u'source']) > 1:
            soids = set([s[u'@soid'] for s in spacer[u'source']])
        else:
            soids = set([spacer[u'source'][u'@soid']])
        spacers[spid] = {'seq': spseq, 'soids': soids}
    return spacers


def extract_contigs(group):
    spcont = set()  # the set of spacers lying in contigs
    for contig in group[u'assembly'][u'contig']:
        slist = []
        if u'cspacer' in contig:
            if u'@spid' in contig[u'cspacer']:
                slist.append(contig[u'cspacer'][u'@spid'])
                spcont.add(contig[u'cspacer'][u'@spid'])
            else:
                for spacer in contig[u'cspacer']:
                    slist.append(spacer[u'@spid'])
                    spcont.add(spacer[u'@spid'])
    return spcont


def extract_info_all(doc):
    sources = {}
    spacers = {}
    groups = {}
    spcont = {}
    for igroup, group in enumerate(doc[u'crispr'][u'group'][:]):
        gid = group[u'@gid']
        drseq = group[u'@drseq']
        groups[gid] = drseq
        sources[gid] = extract_sources(group)
        spacers[gid] = extract_spacers(group)
        spcont[gid] = extract_contigs(group)
    return groups, spacers, sources, spcont


def fiter_DR_shared_spacers(spacers, groups, nnuc=9):
    from Bio.Seq import Seq
    print("\nSpacer count before DR-shared spacer removal:", sum([len(spacers[i]) for i in spacers]))
    # remove clusters where a spacer shares the first or last n-bases
    # with an n-mer in the repeat (anywhere in the repeat).
    for gid in spacers:
        group = spacers[gid]
        torem = set()
        drseq = groups[gid]
        for spid in group:
            spseq = group[spid]['seq']
            flanker1, flanker2 = spseq[:9], spseq[9:]
            rev1 = str(Seq(flanker1).reverse_complement())
            rev2 = str(Seq(flanker2).reverse_complement())
            if flanker1 in drseq or flanker2 in drseq or rev1 in drseq or rev2 in drseq:
                torem.add(spid)
        for spid in torem:
            del group[spid]
    print("Spacer count after DR-shared spacer removal:", sum([len(spacers[i]) for i in spacers]))
    return spacers

def filter_similar_spacers(spacers, nnuc=9):
    print("\nSpacer count before similar spacer removal:", sum([len(spacers[i]) for i in spacers]))
    for gid in spacers:
        group = spacers[gid]
        torem = set()  # spacer ids to be removed
        for spid1 in group:
            # record all spacers similar to this one in the first nine characters
            similar = set()
            for spid2 in group:
                if group[spid1]['seq'][:nnuc] == group[spid2]['seq'][:nnuc] or \
                group[spid1]['seq'][nnuc:] == group[spid2]['seq'][nnuc:]:
                    similar.add(spid2)
            if len(similar)>1:
                torem |= similar
        # remove this spacer if there are other similar spacers
        for spid in torem:
            del group[spid]
    print("Spacer count after similar spacer removal:", sum([len(spacers[i]) for i in spacers]))
    return spacers


def filter_single_spacers(spacers, spcont):
    print("\nSpacer count before single spacer removal:", sum([len(spacers[i]) for i in spacers]))
    for gid in spacers:
        group = spacers[gid]
        torem = set()  # spacer ids to be removed
        for spid in group:
            if spid not in spcont[gid]:
                torem.add(spid)
        for spid in torem:
            del group[spid]
    print("Spacer count after single spacer removal:", sum([len(spacers[i]) for i in spacers]))
    return spacers

def write_table(fpath, sample_list, groups, spacers, sources):
    samples = {s:i for i,s in enumerate(sample_list)}
    f = open(fpath,"w")
    data = ["CRISPRid","DRseq","SPid","SPseq"] + sample_list
    f.write("\t".join(data)+'\n')

    for gid in spacers:
        drseq = groups[gid]
        for spid in spacers[gid]:
            spacer = spacers[gid][spid]
            spseq = spacer['seq']
            spcounts = [0 for i in sample_list]
            for soid in spacer['soids']:
                sampleid = sources[gid][soid].split(':')[0]
                spcounts[samples[sampleid]] += 1
            data = [gid, drseq, spid, spseq] + [str(c) for c in spcounts]
            f.write("\t".join(data)+'\n')
    print("Wrote data to:", fpath)
    return


def write_spacer_table(doc, fpath, sample_list, debug=False):
    """This outputs the counts table only for the spacers that have a specified assembly order"""
    samples = {s: i for i, s in enumerate(sample_list)}
    f = open(fpath, "w")
    data = ["CRISPRid", "DRseq", "SPid", "SPseq"] + sample_list
    f.write("\t".join(data)+'\n')
    for igroup, group in enumerate(doc[u'crispr'][u'group'][:]):
        gid = group[u'@gid']
        drseq = group[u'@drseq']
        sources = {}
        for source in group[u'data'][u'sources'][u'source']:
            sources[source[u'@soid']] = source[u'@accession']
        spacers = {}
        for spacer in group[u'data'][u'spacers'][u'spacer']:
            spid = spacer[u'@spid']
            spseq = spacer[u'@seq']
            if len(spacer[u'source']) > 1:
                soids = set([s[u'@soid'] for s in spacer[u'source']])
            else:
                soids = set([spacer[u'source'][u'@soid']])
            spacers[spid] = [sources[soid] for soid in soids]
        contigs = []
        spcont = set()  # the set of spacers lying in contigs
        for contig in group[u'assembly'][u'contig']:
            slist = []
            if u'cspacer' in contig:
                if u'@spid' in contig[u'cspacer']:
                    slist.append(contig[u'cspacer'][u'@spid'])
                    spcont.add(contig[u'cspacer'][u'@spid'])
                else:
                    for spacer in contig[u'cspacer']:
                        slist.append(spacer[u'@spid'])
                        spcont.add(spacer[u'@spid'])
            contigs.append(slist)
        if debug is True:
            print("gid:", gid, "drseq:", drseq)
            print("sources:", sources)
            print("spacers:", spacers)
            print("contigs:", contigs)
            print("spacers in contigs:", spcont)
        # Now write the table
        for spacer in group[u'data'][u'spacers'][u'spacer']:
            spid = spacer[u'@spid']
            if debug is True:
                print("spid", spid)
            if spid in spcont:
                spseq = spacer[u'@seq']
                if len(spacer[u'source']) > 1:
                    soids = set([s[u'@soid'] for s in spacer[u'source']])
                else:
                    soids = set([spacer[u'source'][u'@soid']])
                spcounts = [0 for i in sample_list]
                for soid in soids:
                    if debug is True:
                        print("soid:", soid, "source", sources[soid])
                    sampleid = sources[soid].split(":")[0]
                    #print(spcounts)
                    #print(samples)
                    #print(sampleid)
                    #print(sources[soid])
                    spcounts[samples[sampleid]] += 1
                if debug is True:
                    print("gid, drseq, spid, spseq, spcounts")
                    print(gid, drseq, spid, spseq, spcounts)
                data = [gid, drseq, spid, spseq] + [str(c) for c in spcounts]
                f.write("\t".join(data)+'\n')
    f.close()
    print("File printed!")
    return
